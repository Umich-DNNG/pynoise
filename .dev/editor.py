'''The program that interacts with the settings object.'''

import settings as set
import os
import time
from subprocess import call

class Editor:

    def __init__(self):

        '''The initializer for the Editor class. Creates 
        a blank settings object, blank log path, and gets 
        the working directory for making absolute paths.'''

        self.parameters = set.Settings()
        self.history = None
        os.chdir(os.path.dirname(os.path.realpath(__file__)))

    def log(self, output):

        '''Prints the output statement to the command line 
        and saves it to the log if logs are enabled.
        
        The output statement must be a string.'''

        print(output)
        if self.history is not None:
            curTime = time.localtime()
            output = (str(curTime.tm_year) 
            + '-' + str(curTime.tm_mon) 
            + '-' + str(curTime.tm_mday) 
            + ' @ ' + str(curTime.tm_hour) 
            + (':0' if curTime.tm_min < 10 else ':') + str(curTime.tm_min) 
            + (':0' if curTime.tm_sec < 10 else ':') + str(curTime.tm_sec) 
            + ' - ' + output)
            self.history.write(output)
            self.history.flush()

    def changeLog(self):

        '''Change the current use of the log file.
        
        If setting changed:
        * True -> False - close log file and delete it.
        * False -> True - create/open new log file named with current timestamp.
        * True -> True - does nothing (prevents recreation of log file).
        * False -> False - does nothing (prevents closing/deletion of nonexistent file).'''

        if self.parameters.settings['Input/Output Settings']['Keep logs'] and self.history is None:
            curTime = time.localtime()
            logName = ('../.logs/' + str(curTime.tm_year) 
                        + '-' + str(curTime.tm_mon) 
                        + '-' + str(curTime.tm_mday) 
                        + '@' + str(curTime.tm_hour) 
                        + (':0' if curTime.tm_min < 10 else ':') + str(curTime.tm_min) 
                        + (':0' if curTime.tm_sec < 10 else ':') + str(curTime.tm_sec) 
                        + '.log')
            logName = os.path.abspath(logName)
            self.history = open(logName,'w')
        elif not self.parameters.settings['Input/Output Settings']['Keep logs'] and self.history is not None:
            self.history.close()
            os.remove(self.history.name)
            self.history = None

    def compare(self):

        '''Compare the current settings to the most recently 
        imported version to see if they have changed.
        
        Logs any changes that have been made.'''

        self.parameters.changed = False
        if (self.parameters.origin == os.path.abspath('new.set') 
            and not os.path.isfile(os.path.abspath('comp.set'))):
                self.log('Created new settings.\n')
                self.parameters.changed = True
        else:
            baseline = set.Settings()
            if os.path.isfile(os.path.abspath('comp.set')):
                baseline.read(os.path.abspath('comp.set'))
                self.parameters.changed = True
                os.remove(os.path.abspath('comp.set'))
            else:
                baseline.read(self.parameters.origin)
            for group in self.parameters.settings:
                for setting in self.parameters.settings[group]:
                    if baseline.settings[group].get(setting) != self.parameters.settings[group][setting]:
                        self.log(setting + ' in ' + group + ' updated to ' 
                        + str(self.parameters.settings[group][setting]) + '.\n')
                        self.parameters.changed = True

    def edit(self, file):

        '''The function that allows the user to edit settings 
        in a vim and save them to runtime afterwards.
        
        Requires a filename of the .set file being opened.
        
        The only files that should be edited in the vim are current 
        and new settings (current.set and new.set respectively).'''

        EDITOR = os.environ.get('EDITOR', 'vim')
        with open(os.path.abspath(file),'a') as settings:
            call([EDITOR, settings.name])
        if (file == 'current.set' 
            and self.parameters.origin == os.path.abspath('new.set')):
            self.parameters.write(os.path.abspath('comp.set'),
                                  'A temporary file used to check changes in '
                                  + 'settings originally started from a blank '
                                  + 'settings file.\n DO NOT EDIT THIS FILE! '
                                  + 'If it persists after runtime, notify the '
                                  + 'dev team and delete it.\n')
        self.parameters.read(os.path.abspath(file))
        self.changeLog()
        print('Settings viewer/editor closed.\n')
        self.compare()
        if self.parameters.settings['Input/Output Settings']['Input type'] == 0:
            print('WARNING: with the current settings, the input file'
                + '/folder is not specified. You must add it manually.')
        os.remove(os.path.abspath(file))

    def driver(self):

        '''The driver that manages the settings vim for editing/viewing.'''

        choice = 'blank'
        file = ''
        while choice != '':
            print('What settings do you want to edit/view?')
            print('c - current settings')
            print('i - import a .set file')
            print('n - new settings')
            print('Leave the command blank to cancel editing/viewing.')
            choice = input('Enter command: ')
            match choice:
                case 'c':
                    print('Opening current settings...')
                    file = 'current.set'
                    self.parameters.write(os.path.abspath(file),
                                          'The current settings during runtime.\n'
                                          + 'This file is temporary and will be '
                                          + 'deleted after editing is done.\n')
                    self.edit(file)
                case 'i':
                    file = 'blank'
                    while not os.path.isfile(os.path.abspath(file)) and file != '.set':
                        file = input('Enter a settings file (no .set '
                                     + 'extension) or leave blank to cancel: ')
                        file = file + '.set'
                        if os.path.isfile(os.path.abspath(file)):
                            print('Importing ' + file + '...')
                            self.parameters.read(os.path.abspath(file))
                            self.changeLog()
                            self.log('Imported settings from ' + file + '.\n')
                        elif file == '.set':
                            print('Canceling import...\n')
                        else:
                            print('ERROR: ' + file + ' does not exist in this directory. '
                                  + 'Make sure that your settings file is named '
                                  + 'correctly and in the same folder as this program.\n')
                case 'n':
                    print('Opening new settings...')
                    file = 'new.set'
                    blank = set.Settings()
                    blank.write(os.path.abspath(file),
                                'A new settings file.\n'
                                + 'This file is temporary and will be '
                                + 'deleted after editing is done.\n')
                    self.edit(file)
                case '':
                    print('Returning to previous menu...\n')
                case _:
                    print('Unrecognized command. Please review the list of appriopriate inputs.\n')